{"version":3,"sources":["tangojs-connector-local.min.js","/source/tangojs-connector-local.js"],"names":["global","factory","define","amd","exports","mod","tangojsConnectorLocal","this","_possibleConstructorReturn","self","call","ReferenceError","_typeof","_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","obj","Symbol","flatten","object","depth","separator","keys","reduce","flattened","key1","merged","undefined","child","acc","key2","assign","reject","message","Promise","Error","defineProperty","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_s","_i","iterator","next","done","push","length","err","Array","isArray","_createClass","defineProperties","target","props","descriptor","key","protoProps","staticProps","wrapAsPromisedArray","x","resolve","extractPropnames","propnames","map","p","tangojs","struct","DbDatum","name","String","filter","asRegex","pattern","RegExp","replace","slash","DeviceTreeInspector","model","_model","devname","_devname$split","split","_devname$split2","domain","family","member","error","attname","getDevice","then","device","attributes","cmdname","commands","propname","properties","match","LocalConnector","_tangojs$Connector","inspector","_this","getPrototypeOf","_tree","get_status","get_state","get_info","regex","getDeviceNameList","list","s","_this2","getProperty","all","prop","forEach","attnames","_this3","names","get_device_attribute_list","n","getAttribute","a","infos","_this4","get_value","attrs","_this5","nvList","_ref","_ref2","attr","set_value","argin","getCommand","cmd","inout","_this6","cmdnames","Connector"],"mappings":"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","file":"tangojs-connector-local.min.js","sourcesContent":["'use strict';\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports);\n    global.tangojsConnectorLocal = mod.exports;\n  }\n})(this, function (exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  function _possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var _slicedToArray = (function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n\n      return _arr;\n    }\n\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  })();\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var _createClass = (function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  })();\n\n  function _typeof(obj) {\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n  }\n\n  var wrapAsPromisedArray = function wrapAsPromisedArray(x) {\n    return Promise.resolve(Array.isArray(x) ? x : [x]);\n  };\n\n  var extractPropnames = function extractPropnames(propnames) {\n    return (Array.isArray(propnames) ? propnames : [propnames]).map(function (p) {\n      return p instanceof tangojs.struct.DbDatum ? p.name : typeof p === 'string' || p instanceof String ? p : '';\n    }).filter(function (p) {\n      return p !== '';\n    });\n  };\n\n  var asRegex = function asRegex(pattern) {\n    return new RegExp(pattern.replace('*', '.*'), 'g');\n  };\n\n  var slash = new RegExp('/', 'g');\n\n  function flatten(object, depth, separator) {\n    return depth === 1 ? object : Object.keys(object).reduce(function (flattened, key1) {\n      var value = object[key1];\n      var merged = undefined;\n\n      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || value == null) {\n        merged = {};\n        merged[key1] = value;\n      } else {\n        (function () {\n          var child = flatten(object[key1], depth - 1, separator);\n          merged = Object.keys(child).reduce(function (acc, key2) {\n            acc['' + key1 + separator + key2] = child[key2];\n            return acc;\n          }, {});\n        })();\n      }\n\n      return Object.assign(flattened, merged);\n    }, {});\n  }\n\n  function reject(message) {\n    return Promise.reject(new Error(message));\n  }\n\n  var DeviceTreeInspector = (function () {\n    function DeviceTreeInspector(model) {\n      _classCallCheck(this, DeviceTreeInspector);\n\n      this._model = model;\n    }\n\n    _createClass(DeviceTreeInspector, [{\n      key: 'getDevice',\n      value: function getDevice(devname) {\n        try {\n          var _devname$split = devname.split('/');\n\n          var _devname$split2 = _slicedToArray(_devname$split, 3);\n\n          var domain = _devname$split2[0];\n          var family = _devname$split2[1];\n          var member = _devname$split2[2];\n          return Promise.resolve(this._model[domain][family][member]);\n        } catch (error) {\n          return reject('Invalid device name: \\'' + name + '\\'');\n        }\n      }\n    }, {\n      key: 'getAttribute',\n      value: function getAttribute(devname, attname) {\n        return this.getDevice(devname).then(function (device) {\n          return device.attributes && device.attributes[attname] ? device.attributes[attname] : reject('Attribute not found: \\'' + devname + '/' + attname + '\\'');\n        });\n      }\n    }, {\n      key: 'getCommand',\n      value: function getCommand(devname, cmdname) {\n        return this.getDevice(devname).then(function (device) {\n          return device.commands && device.commands[cmdname] ? device.commands[cmdname] : reject('Command not found: \\'' + devname + '/' + cmdname + '\\'');\n        });\n      }\n    }, {\n      key: 'getProperty',\n      value: function getProperty(devname, propname) {\n        return this.getDevice(devname).then(function (device) {\n          return device.properties && device.properties[propname] ? device.properties[propname] : reject('Property not found: \\'' + devname + '/' + propname + '\\'');\n        });\n      }\n    }, {\n      key: 'getDeviceNameList',\n      value: function getDeviceNameList() {\n        return Object.keys(flatten(this._model, 3, '/')).filter(function (key) {\n          return (key.match(slash) || []).length === 2;\n        });\n      }\n    }]);\n\n    return DeviceTreeInspector;\n  })();\n\n  var LocalConnector = (function (_tangojs$Connector) {\n    _inherits(LocalConnector, _tangojs$Connector);\n\n    function LocalConnector(model, inspector) {\n      _classCallCheck(this, LocalConnector);\n\n      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LocalConnector).call(this));\n\n      _this._model = model;\n      _this._tree = inspector || new DeviceTreeInspector(model);\n      return _this;\n    }\n\n    _createClass(LocalConnector, [{\n      key: 'get_device_status',\n      value: function get_device_status(devname) {\n        return this._tree.getDevice(devname).then(function (device) {\n          return device.get_status();\n        });\n      }\n    }, {\n      key: 'get_device_state',\n      value: function get_device_state(devname) {\n        return this._tree.getDevice(devname).then(function (device) {\n          return device.get_state();\n        });\n      }\n    }, {\n      key: 'get_device_info',\n      value: function get_device_info(devname) {\n        return this._tree.getDevice(devname).then(function (device) {\n          return device.get_info();\n        });\n      }\n    }, {\n      key: 'get_device_list',\n      value: function get_device_list(pattern) {\n        var regex = asRegex(pattern);\n        return this._tree.getDeviceNameList().then(function (list) {\n          return list.filter(function (s) {\n            return s.match(regex);\n          });\n        });\n      }\n    }, {\n      key: 'get_device_domain',\n      value: function get_device_domain(pattern) {\n        throw new Error(pattern);\n      }\n    }, {\n      key: 'get_device_family',\n      value: function get_device_family(pattern) {\n        throw new Error(pattern);\n      }\n    }, {\n      key: 'get_device_member',\n      value: function get_device_member(pattern) {\n        throw new Error(pattern);\n      }\n    }, {\n      key: 'get_device_property_list',\n      value: function get_device_property_list(devname, pattern) {\n        var regex = asRegex(pattern);\n        return this._tree.getDevice(devname).then(function (device) {\n          return Object.keys(device.properties).filter(function (s) {\n            return s.match(regex);\n          });\n        });\n      }\n    }, {\n      key: 'get_device_property',\n      value: function get_device_property(devname, propnames) {\n        var _this2 = this;\n\n        var props = extractPropnames(propnames).map(function (p) {\n          return _this2._tree.getProperty(devname, p);\n        });\n        return Array.isArray(propnames) ? Promise.all(props) : props[0];\n      }\n    }, {\n      key: 'put_device_property',\n      value: function put_device_property(devname, prop) {\n        return this._tree.getDevice(devname).then(function (device) {\n          device.properties = device.properties || {};\n          device.properties[prop.name] = prop;\n        });\n      }\n    }, {\n      key: 'delete_device_property',\n      value: function delete_device_property(devname, propnames) {\n        return this._tree.getDevice(devname).then(function (device) {\n          extractPropnames(propnames).forEach(function (p) {\n            delete device.properties[p];\n          });\n        });\n      }\n    }, {\n      key: 'get_device_attribute_list',\n      value: function get_device_attribute_list(devname) {\n        return this._tree.getDevice(devname).then(function (device) {\n          return Object.keys(device.attributes);\n        });\n      }\n    }, {\n      key: 'get_device_attribute_info',\n      value: function get_device_attribute_info(devname, attnames) {\n        var _this3 = this;\n\n        var names = attnames ? wrapAsPromisedArray(attnames) : this.get_device_attribute_list(devname);\n        return names.then(function (names) {\n          return Promise.all(names.map(function (n) {\n            return _this3._tree.getAttribute(devname, n).then(function (a) {\n              return a.get_info();\n            });\n          }));\n        }).then(function (infos) {\n          return attnames ? Array.isArray(attnames) ? infos : infos[0] : infos;\n        });\n      }\n    }, {\n      key: 'read_device_attribute',\n      value: function read_device_attribute(devname, attnames) {\n        var _this4 = this;\n\n        return wrapAsPromisedArray(attnames).then(function (attnames) {\n          return Promise.all(attnames.map(function (attname) {\n            return _this4._tree.getAttribute(devname, attname).then(function (a) {\n              return a.get_value();\n            });\n          }));\n        }).then(function (attrs) {\n          return Array.isArray(attnames) ? attrs : attrs[0];\n        });\n      }\n    }, {\n      key: 'write_device_attribute',\n      value: function write_device_attribute(devname, attrs) {\n        var _this5 = this;\n\n        return wrapAsPromisedArray(attrs).then(function (attrs) {\n          return attrs.map(function (a) {\n            return [a.name, a.value];\n          });\n        }).then(function (nvList) {\n          return Promise.all(nvList.map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2);\n\n            var name = _ref2[0];\n            var value = _ref2[1];\n            return _this5._tree.getAttribute(devname, name).then(function (attr) {\n              return attr.set_value(value);\n            });\n          }));\n        });\n      }\n    }, {\n      key: 'write_read_device_attribute',\n      value: function write_read_device_attribute(devname, attrs) {\n        attrs;\n        throw new Error('not implemented yet');\n      }\n    }, {\n      key: 'device_command_inout',\n      value: function device_command_inout(devname, cmdname, argin) {\n        return this._tree.getCommand(devname, cmdname).then(function (cmd) {\n          return cmd.inout(argin);\n        });\n      }\n    }, {\n      key: 'device_command_query',\n      value: function device_command_query(devname, cmdname) {\n        return this._tree.getCommand(devname, cmdname).then(function (cmd) {\n          return cmd.get_info();\n        });\n      }\n    }, {\n      key: 'device_command_list_query',\n      value: function device_command_list_query(devname) {\n        var _this6 = this;\n\n        return this._tree.getDevice(devname).then(function (device) {\n          return Object.keys(device.commands);\n        }).then(function (cmdnames) {\n          return Promise.all(cmdnames.map(function (cmdname) {\n            return _this6._tree.getCommand(devname, cmdname).then(function (cmd) {\n              return cmd.get_info();\n            });\n          }));\n        });\n      }\n    }]);\n\n    return LocalConnector;\n  })(tangojs.Connector);\n\n  exports.LocalConnector = LocalConnector;\n});\n//# sourceMappingURL=tangojs-connector-local.js.map\n","/** @private */\nlet wrapAsPromisedArray = (x) => Promise.resolve(Array.isArray(x) ? x : [x])\n\n\n/** @private */\nlet extractPropnames = (propnames) => {\n  return (Array.isArray(propnames) ? propnames : [propnames])\n    .map(p => (p instanceof tangojs.struct.DbDatum) ? p.name\n            : (typeof p === 'string' || p instanceof String) ? p\n            : '')\n    .filter(p => p !== '')\n}\n\n\n/** @private */\nlet asRegex = (pattern) => new RegExp(pattern.replace('*', '.*'), 'g')\n\n\n/** @private */\nconst slash = new RegExp('/', 'g')\n\n/** @private */\nfunction flatten(object, depth, separator) {\n  return (depth === 1) ? object\n  : Object.keys(object).reduce((flattened, key1) => {\n    let value = object[key1]\n    let merged\n    if (typeof value !== 'object' || value == null) {\n      merged = {}\n      merged[key1] = value\n    } else {\n      let child = flatten(object[key1], depth-1, separator)\n      merged = Object.keys(child).reduce((acc, key2) => {\n        acc[`${key1}${separator}${key2}`] = child[key2]\n        return acc\n      }, {})\n    }\n    return Object.assign(flattened, merged)\n  }, {})\n}\n\n\n/** @private */\nfunction reject(message) {\n  return Promise.reject(new Error(message))\n}\n\nclass DeviceTreeInspector {\n\n  /**\n   * @param {Object} model\n   */\n  constructor(model) {\n    /** @private */\n    this._model = model\n  }\n\n  /**\n   * @param {string} devname\n   * @return {Promise<Object>}\n   */\n  getDevice(devname) {\n    try {\n      let [domain, family, member] = devname.split('/')\n      return Promise.resolve(this._model[domain][family][member])\n    } catch (error) {\n      return reject(`Invalid device name: '${name}'`)\n    }\n  }\n\n  /**\n   * @param {string} devname\n   * @param {string} attname\n   * @return {Promise<Object>}\n   */\n  getAttribute(devname, attname) {\n    return this.getDevice(devname).then(device =>\n      device.attributes && device.attributes[attname]\n        ? device.attributes[attname]\n        : reject(`Attribute not found: '${devname}/${attname}'`)\n    )\n  }\n\n  /**\n   * @param {string} devname\n   * @param {string} cmdname\n   * @return {Promise<Object>}\n   */\n  getCommand(devname, cmdname) {\n    return this.getDevice(devname).then(device =>\n      device.commands && device.commands[cmdname]\n        ? device.commands[cmdname]\n        : reject(`Command not found: '${devname}/${cmdname}'`)\n    )\n  }\n\n  /**\n   * @param {string} devname\n   * @param {string} propname\n   * @return {Promise<Object>}\n   */\n  getProperty(devname, propname) {\n    return this.getDevice(devname).then(device =>\n      device.properties && device.properties[propname]\n        ? device.properties[propname]\n        : reject(`Property not found: '${devname}/${propname}'`)\n    )\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   */\n  getDeviceNameList() {\n    return Object.keys(flatten(this._model, 3, '/'))\n      .filter(key => (key.match(slash) || []).length === 2)\n  }\n}\n\n\n/**\n * In-memory connector implementation.\n */\nclass LocalConnector extends tangojs.Connector {\n\n  /**\n   * @param {Object} model\n   * @param {DeviceTreeInspector} treeInspector\n   */\n  constructor(model, inspector) {\n    super()\n    /** @private */\n    this._model = model\n    /** @private */\n    this._tree = inspector || new DeviceTreeInspector(model)\n  }\n\n  /**\n   * @return {Promise<string>}\n   * @param {string} devname\n   */\n  get_device_status(devname) {\n    return this._tree.getDevice(devname)\n      .then(device => device.get_status())\n  }\n\n  /**\n   * @return {Promise<DevState>}\n   * @param {string} devname\n   */\n  get_device_state(devname) {\n    return this._tree.getDevice(devname)\n      .then(device => device.get_state())\n  }\n\n  /**\n   * @return {Promise<DeviceInfo>}\n   * @param {string} devname\n   */\n  get_device_info(devname) {\n    return this._tree.getDevice(devname)\n      .then(device => device.get_info())\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} pattern\n   */\n  get_device_list(pattern) {\n    let regex = asRegex(pattern)\n    return this._tree.getDeviceNameList()\n      .then(list => list.filter(s => s.match(regex)))\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} pattern\n   */\n  get_device_domain(pattern) {\n    throw new Error(pattern)\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} pattern\n   */\n  get_device_family(pattern) {\n    throw new Error(pattern)\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} pattern\n   */\n  get_device_member(pattern) {\n    throw new Error(pattern)\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} devname\n   * @param {string} pattern\n   */\n  get_device_property_list(devname, pattern) {\n    let regex = asRegex(pattern)\n    return this._tree.getDevice(devname)\n      .then(device => Object.keys(device.properties)\n                        .filter(s => s.match(regex)))\n  }\n\n  /**\n   * @return {Promise<DbDatum>|Promise<DbDatum[]>}\n   * @param {string} devname\n   * @param {string|string[]|DbDatum[]} propnames\n   */\n  get_device_property(devname, propnames) {\n    let props = extractPropnames(propnames)\n      .map(p => this._tree.getProperty(devname, p))\n    return Array.isArray(propnames) ? Promise.all(props) : props[0]\n  }\n\n  /**\n   * @return {Promise<undefined>}\n   * @param {string} devname\n   * @param {DbDatum[]} properties\n   */\n  put_device_property(devname, prop) {\n    return this._tree.getDevice(devname).then(device => {\n      device.properties = device.properties || {}\n      device.properties[prop.name] = prop\n    })\n  }\n\n  /**\n   * @return {Promise<undefined>}\n   * @param {string} devname\n   * @param {string|string[]|DbDatum[]} propnames property names\n   */\n  delete_device_property(devname, propnames) {\n    return this._tree.getDevice(devname).then(device => {\n      extractPropnames(propnames).forEach(p => {\n        delete device.properties[p]\n      })\n    })\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} devname\n   */\n  get_device_attribute_list(devname) {\n    return this._tree.getDevice(devname)\n      .then(device => Object.keys(device.attributes))\n  }\n\n  /**\n   * @return {Promise<AttributeInfo>|Promise<AttributeInfo[]>}\n   * @param {string} devname\n   * @param {undefined|string|string[]} attnames\n   */\n  get_device_attribute_info(devname, attnames) {\n    let names = attnames ? wrapAsPromisedArray(attnames)\n      : this.get_device_attribute_list(devname)\n    return names.then(names => {\n      return Promise.all(names.map(n => {\n        return this._tree.getAttribute(devname, n)\n          .then(a => a.get_info())\n      }))\n    })\n    .then(infos => {\n      return attnames ? Array.isArray(attnames) ? infos : infos[0]\n        : infos\n    })\n  }\n\n  /**\n   * @return {Promise<DeviceAttribute>|Promise<DeviceAttribute[]>}\n   * @param {string} devname\n   * @param {string|string[]} attname\n   */\n  read_device_attribute(devname, attnames) {\n    return wrapAsPromisedArray(attnames).then(attnames => {\n      return Promise.all(attnames.map(attname => {\n        return this._tree.getAttribute(devname, attname)\n          .then(a => a.get_value())\n      }))\n    })\n    .then(attrs => Array.isArray(attnames) ? attrs : attrs[0] )\n  }\n\n  /**\n  * @return {Promise<undefined>}\n   * @param {string} devname\n   * @param {DeviceAttribute|DeviceAttribute[]} attrs\n   */\n  write_device_attribute(devname, attrs) {\n    return wrapAsPromisedArray(attrs)\n      .then(attrs => attrs.map(a => [a.name, a.value]))\n      .then(nvList => Promise.all(nvList.map(([name, value]) =>\n        this._tree.getAttribute(devname, name)\n          .then(attr => attr.set_value(value))\n      )))\n  }\n\n  /**\n   * @return {Promise<DeviceAttribute>|Promise<DeviceAttribute[]>}\n   * @param {string} devname\n   * @param {DeviceAttribute|DeviceAttribute[]} attrs\n   */\n  write_read_device_attribute(devname, attrs) {\n    attrs\n    throw new Error('not implemented yet')\n  }\n\n  /**\n   * @return {Promise<DeviceData>}\n   * @param {string} devname\n   * @param {string} cmdname\n   * @param {undefined|DeviceData} argin\n   */\n  device_command_inout(devname, cmdname, argin) {\n    return this._tree.getCommand(devname, cmdname)\n      .then(cmd => cmd.inout(argin))\n  }\n\n  /**\n   * @return {Promise<CommandInfo>}\n   * @param {string} devname\n   * @param {string} cmdname\n   */\n  device_command_query(devname, cmdname) {\n    return this._tree.getCommand(devname, cmdname)\n      .then(cmd => cmd.get_info())\n  }\n\n  /**\n   * @return {Promise<CommandInfo[]>}\n   * @param {string} devname\n   */\n  device_command_list_query(devname) {\n    return this._tree.getDevice(devname)\n      .then(device => Object.keys(device.commands))\n      .then(cmdnames => Promise.all(\n        cmdnames.map(cmdname =>\n          this._tree.getCommand(devname, cmdname)\n            .then(cmd => cmd.get_info())\n        )\n      ))\n  }\n}\n\nexport { LocalConnector };"],"sourceRoot":"/source/"}