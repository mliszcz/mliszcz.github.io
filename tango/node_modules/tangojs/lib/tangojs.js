(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['exports'], factory);
  } else if (typeof exports !== 'undefined') {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.tangojs = mod.exports;
  }
})(this, function (exports) {
  /**
   * Immutable structure that contains information about an attribute.
   * @see http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/tango_java_api/classes/fr/esrf/TangoApi/AttributeInfo.html
   */
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });

  var _get = function get(_x11, _x12, _x13) { var _again = true; _function: while (_again) { var object = _x11, property = _x12, receiver = _x13; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x11 = parent; _x12 = property; _x13 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  var AttributeInfo = (function () {

    /**
     * Creates new AttributeInfo.
     * @param {Object} info serialized AttributeInfo from TangORB.
     */

    function AttributeInfo(info) {
      _classCallCheck(this, AttributeInfo);

      /** @access private */
      this._info = info;
      Object.freeze(this);
      Object.freeze(this._info);
    }

    /**
     * Immutable structure that contains information about a command.
     * @see http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/tango_java_api/classes/fr/esrf/TangoApi/CommandInfo.html
     */

    /** @type {AttributeDataFormat} */

    _createClass(AttributeInfo, [{
      key: 'data_format',
      get: function get() {
        return this._info['data_format'];
      }

      /** @type {number} */
    }, {
      key: 'data_type',
      get: function get() {
        return this._info['data_type'];
      }

      /** @type {string} */
    }, {
      key: 'description',
      get: function get() {
        return this._info['description'];
      }

      /** @type {string} */
    }, {
      key: 'display_unit',
      get: function get() {
        return this._info['display_unit'];
      }

      /** @type {string[]} */
    }, {
      key: 'extensions',
      get: function get() {
        return this._info['extensions'];
      }

      /** @type {string} */
    }, {
      key: 'format',
      get: function get() {
        return this._info['format'];
      }

      /** @type {string} */
    }, {
      key: 'label',
      get: function get() {
        return this._info['label'];
      }

      /** @type {DisplayLevel} */
    }, {
      key: 'level',
      get: function get() {
        return this._info['level'];
      }

      /** @type {string} */
    }, {
      key: 'max_alarm',
      get: function get() {
        return this._info['max_alarm'];
      }

      /** @type {number} */
    }, {
      key: 'max_dim_x',
      get: function get() {
        return this._info['max_dim_x'];
      }

      /** @type {number} */
    }, {
      key: 'max_dim_y',
      get: function get() {
        return this._info['max_dim_y'];
      }

      /** @type {string} */
    }, {
      key: 'max_value',
      get: function get() {
        return this._info['max_value'];
      }

      /** @type {string} */
    }, {
      key: 'min_alarm',
      get: function get() {
        return this._info['min_alarm'];
      }

      /** @type {string} */
    }, {
      key: 'min_value',
      get: function get() {
        return this._info['min_value'];
      }

      /** @type {string} */
    }, {
      key: 'name',
      get: function get() {
        return this._info['name'];
      }

      /** @type {string} */
    }, {
      key: 'standard_unit',
      get: function get() {
        return this._info['standard_unit'];
      }

      /** @type {string} */
    }, {
      key: 'unit',
      get: function get() {
        return this._info['unit'];
      }

      /** @type {AttributeWriteType} */
    }, {
      key: 'writable',
      get: function get() {
        return this._info['writable'];
      }

      /** @type {string} */
    }, {
      key: 'writable_attr_name',
      get: function get() {
        return this.inf['writable_attr_name'];
      }
    }]);

    return AttributeInfo;
  })();

  var CommandInfo = (function () {

    /**
     * Creates new CommandInfo.
     * @param {Object} info serialized CommandInfo from TangORB.
     */

    function CommandInfo(info) {
      _classCallCheck(this, CommandInfo);

      /** @access private */
      this._info = info;
      Object.freeze(this);
      Object.freeze(this._info);
    }

    /* eslint-disable no-unused-vars */

    /**
     * Tangojs connector interface. This class contains backend-specific
     * logic. Each connector plugin have to provide implementation
     * of this interface.
     * @interface
     */

    /** @type {string} */

    _createClass(CommandInfo, [{
      key: 'cmd_name',
      get: function get() {
        return this._info['cmd_name'];
      }

      /** @type {number} */
    }, {
      key: 'cmd_tag',
      get: function get() {
        return this._info['cmd_tag'];
      }

      /** @type {number} */
    }, {
      key: 'in_type',
      get: function get() {
        return this._info['in_type'];
      }

      /** @type {string} */
    }, {
      key: 'in_type_desc',
      get: function get() {
        return this._info['in_type_desc'];
      }

      /** @type {DisplayLevel} */
    }, {
      key: 'level',
      get: function get() {
        return this._info['level'];
      }

      /** @type {number} */
    }, {
      key: 'out_type',
      get: function get() {
        return this._info['out_type'];
      }

      /** @type {string} */
    }, {
      key: 'out_type_desc',
      get: function get() {
        return this._info['out_type_desc'];
      }
    }]);

    return CommandInfo;
  })();

  var Connector = (function () {
    function Connector() {
      _classCallCheck(this, Connector);
    }

    /**
     * Gives access to the database.
     */

    _createClass(Connector, [{
      key: 'dbReadDomains',

      /**
       * Reads list of all domains.
       * @return {Promise<string[],Error>} result
       */
      value: function dbReadDomains() {}

      /**
       * Reads list of all families in given domain.
       * @param {string} domain domain name
       * @return {Promise<string[],Error>} result
       */
    }, {
      key: 'dbReadFamilies',
      value: function dbReadFamilies(domain) {}

      /**
       * Reads list of all members in given domain and family.
       * @param {string} domain domain name
       * @param {string} family family name
       * @return {Promise<string[],Error>} result
       */
    }, {
      key: 'dbReadMembers',
      value: function dbReadMembers(domain, family) {}

      /**
       * Reads device status.
       * @param {string} deviceName device name
       * @return {Promise<DeviceStatusResponse,Error>} device status
       */
    }, {
      key: 'readDeviceStatus',
      value: function readDeviceStatus(deviceName) {}

      /**
       * Reads device info.
       * @param {string} deviceName device name
       * @return {Promise<DeviceInfo,Error>} device info
       */
    }, {
      key: 'readDeviceInfo',
      value: function readDeviceInfo(deviceName) {}

      /**
       * Reads list of attribute names.
       * @param {string} deviceName device name
       * @return {Promise<string[],Error>} attribute names
       */
    }, {
      key: 'readAttributesList',
      value: function readAttributesList(deviceName) {}

      /**
       * Reads attribute value.
       * @param {string}  deviceName     device name
       * @param {string}  attributeName  attribute name
       * @return {Promise<AttributeReadResponse,Error>} result
       */
    }, {
      key: 'readAttributeValue',
      value: function readAttributeValue(deviceName, attributeName) {}

      /**
       * Writes values into multiple attributes.
       * Returns promise of stored values (if sync is true)
       * or null (if sync is false).
       * @param {string}      deviceName       device name
       * @param {Object[][]}  nameValueTuples  list of 2-element lists [name, value]
       * @param {boolean}     [sync=false]     synchronous / asynchronous call
       * @param {boolean}     [reset=false]    reset not specified attributes
       * @return {Promise<AttributeReadResponse[],Error>|Promise<undefined,Error>}
       */
    }, {
      key: 'writeAttributeValuesBulk',
      value: function writeAttributeValuesBulk(deviceName, nameValueTuples) {
        var sync = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
        var reset = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
      }

      /**
       * Reads attribute info.
       * @param {string}  deviceName     device name
       * @param {string}  attributeName  attribute name
       * @return {Promise<AttributeInfo,Error>} result
       */
    }, {
      key: 'readAttributeInfo',
      value: function readAttributeInfo(deviceName, attributeName) {}

      /**
       * Reads list of command names.
       * @param {string} deviceName device name
       * @return {Promise<string[],Error>} command names
       */
    }, {
      key: 'readCommandsList',
      value: function readCommandsList(deviceName) {}

      /**
       * Reads command info.
       * @param {string}  deviceName   device name
       * @param {string}  commandName  command name
       * @return {Promise<CommandInfo,Error>} result
       */
    }, {
      key: 'readCommandInfo',
      value: function readCommandInfo(deviceName, commandName) {}

      /**
       * Executes command. Pass undefined as argument for 0-arity commands.
       * Returns execution result (if sync is true) or null (if sync is false).
       * @param {string}   deviceName   device name
       * @param {string}   commandName  command name
       * @param {Object}   arg          input argument
       * @param {boolean}  [sync=false] synchronous / asynchronous call
       * @return {Promise<CommandOutputResponse,Error>|Promise<undefined,Error>}
       */
    }, {
      key: 'executeCommand',
      value: function executeCommand(deviceName, commandName, arg, sync) {}
    }]);

    return Connector;
  })();

  var Database = (function () {
    function Database() {
      _classCallCheck(this, Database);
    }

    /**
     * Proxy for accessing device attribute.
     */

    _createClass(Database, [{
      key: 'readDomains',

      /**
       * Reads list of all domains.
       * @return {Promise<string[],Error>} result
       */
      value: function readDomains() {
        return connector.dbReadDomains();
      }

      /**
       * Reads list of all families in given domain.
       * @param {string} domain domain name
       * @return {Promise<string[],Error>} result
       */
    }, {
      key: 'readFamilies',
      value: function readFamilies(domain) {
        return connector.dbReadFamilies(domain);
      }

      /**
       * Reads list of all members in given domain and family.
       * @param {string} domain domain name
       * @param {string} family family name
       * @return {Promise<string[],Error>} result
       */
    }, {
      key: 'readMembers',
      value: function readMembers(domain, family) {
        return connector.dbReadMembers(domain, family);
      }

      // TODO add support for listing and filtering devices
    }]);

    return Database;
  })();

  var DeviceAttribute = (function () {

    /**
     * Creates new DeviceAttribute.
     * @param {DeviceProxy}  deviceProxy    device proxy instance
     * @param {string}       attributeName  attribute name
     */

    function DeviceAttribute(deviceProxy, attributeName) {
      _classCallCheck(this, DeviceAttribute);

      /** @private */
      this.deviceProxy = deviceProxy;
      /** @private */
      this.attributeName = attributeName;
    }

    /**
     * Proxy for executing commands on the device.
     */

    /**
     * Reads attribute value.
     * @return {Promise<AttributeReadResponse,Error>} result
     */

    _createClass(DeviceAttribute, [{
      key: 'readValue',
      value: function readValue() {
        return this.deviceProxy.readAttributeValue(this.attributeName);
      }

      /**
       * Writes attribute value.
       * Returns promise of stored value (if sync is true)
       * or undefined (if sync is false).
       * @param {Object}   value         value to write
       * @param {boolean}  [sync=false]  synchronous / asynchronous call
       * @return {Promise<AttributeReadResponse,Error>|Promise<undefined,Error>}
       */
    }, {
      key: 'writeValue',
      value: function writeValue(value) {
        var sync = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        return this.deviceProxy.writeAttributeValue(this.attributeName, value, sync);
      }

      /**
       * Reads attribute info.
       * @return {Promise<AttributeInfo,Error>} result
       */
    }, {
      key: 'readInfo',
      value: function readInfo() {
        return this.deviceProxy.readAttributeInfo(this.attributeName);
      }
    }]);

    return DeviceAttribute;
  })();

  var DeviceCommand = (function () {

    /**
     * Creates new DeviceCommand.
     * @param {DeviceProxy}  deviceProxy  device proxy instance
     * @param {string}       commandName  command name
     */

    function DeviceCommand(deviceProxy, commandName) {
      _classCallCheck(this, DeviceCommand);

      /** @private */
      this.deviceProxy = deviceProxy;
      /** @private */
      this.commandName = commandName;
    }

    /**
     * Immutable structure that contains information about a device.
     * @see http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/tango_java_api/classes/fr/esrf/TangoApi/DeviceInfo.html
     */

    /**
     * Reads command info.
     * @return {Promise<CommandInfo,Error>} result
     */

    _createClass(DeviceCommand, [{
      key: 'readInfo',
      value: function readInfo() {
        return this.deviceProxy.readCommandInfo(this.commandName);
      }

      /**
       * Executes command. Pass undefined as argument for 0-arity commands.
       * Returns execution result (if sync is true) or undefined (if sync is false).
       * @param {Object}   arg   input argument
       * @param {boolean}  sync  synchronous / asynchronous call
       * @return {Promise<CommandOutputResponse,Error>|Promise<undefined,Error>}
       */
    }, {
      key: 'execute',
      value: function execute() {
        var arg = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];
        var sync = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        return this.deviceProxy.executeCommand(this.commandName, arg, sync);
      }
    }]);

    return DeviceCommand;
  })();

  var DeviceInfo = (function () {

    /**
     * Creates new DeviceInfo.
     * @param {Object} info serialized DeviceInfo from TangORB.
     */

    function DeviceInfo(info) {
      _classCallCheck(this, DeviceInfo);

      /** @access private */
      this._info = info;
      Object.freeze(this);
      Object.freeze(this._info);
    }

    // why those `returns` are here?
    // https://github.com/jashkenas/coffeescript/issues/2359
    // http://stackoverflow.com/questions/10805084/subclassing-native-objects-instanceof-not-working-properly
    // http://stackoverflow.com/questions/19422145/property-in-subclass-of-error-not-set
    // https://github.com/jashkenas/coffeescript/issues/2111

    /**
     * Indicates invalid device name. Thrown by {@link DeviceProxy} constructor.
     */

    /** @type {string} */

    _createClass(DeviceInfo, [{
      key: 'classname',
      get: function get() {
        return this._info['classname'];
      }

      /** @type {boolean} */
    }, {
      key: 'exported',
      get: function get() {
        return this._info['exported'];
      }

      /** @type {string} */
    }, {
      key: 'hostname',
      get: function get() {
        return this._info['hostname'];
      }

      /** @type {string} */
    }, {
      key: 'ior',
      get: function get() {
        return this._info['ior'];
      }

      /** @type {boolean} */
    }, {
      key: 'is_taco',
      get: function get() {
        return this._info['is_taco'];
      }

      /** @type {string} */
    }, {
      key: 'last_exported',
      get: function get() {
        return this._info['last_exported'];
      }

      /** @type {string} */
    }, {
      key: 'last_unexported',
      get: function get() {
        return this._info['last_unexported'];
      }

      /** @type {string} */
    }, {
      key: 'name',
      get: function get() {
        return this._info['name'];
      }

      /** @type {number} */
    }, {
      key: 'pid',
      get: function get() {
        return this._info['pid'];
      }

      /** @type {string} */
    }, {
      key: 'server',
      get: function get() {
        return this._info['server'];
      }

      /** @type {string} */
    }, {
      key: 'taco_info',
      get: function get() {
        return this._info['taco_info'];
      }

      /** @type {string} */
    }, {
      key: 'version',
      get: function get() {
        return this._info['version'];
      }
    }]);

    return DeviceInfo;
  })();

  var InvalidDeviceNameException = (function (_Error) {
    _inherits(InvalidDeviceNameException, _Error);

    /** @param {string} deviceName name of the device */

    function InvalidDeviceNameException(deviceName) {
      _classCallCheck(this, InvalidDeviceNameException);

      return _get(Object.getPrototypeOf(InvalidDeviceNameException.prototype), 'constructor', this).call(this, deviceName + ' is not a valid device name');
    }

    return InvalidDeviceNameException;
  })(Error);

  var deviceNamePattern = /^\w+\/\w+\/\w+$/;

  /**
   * Device proxy that allows one to access attributes and properties of a device.
   */

  var DeviceProxy = (function () {

    /**
     * Creates new DeviceProxy.
     * Takes 1 or 3 arguments.
     * @param {...string} args device name
     * @throws {InvalidDeviceNameException} thrown when device name is invalid
     * @example
     * let p1 = new tangojs.DeviceProxy('my/dev/1')
     * let p2 = new tangojs.DeviceProxy('my', 'dev', '1')
     */

    function DeviceProxy() {
      _classCallCheck(this, DeviceProxy);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var domain = args[0];
      var family = args[1];
      var member = args[2];

      /** @private */
      this.deviceName = domain && family && member ? domain + '/' + family + '/' + member : domain;

      if (!this.deviceName || this.deviceName.search(deviceNamePattern) < 0) throw new InvalidDeviceNameException(this.deviceName);
    }

    /** Base class for responses. */

    /**
     * Returns device name.
     * @return {string} device name
     */

    _createClass(DeviceProxy, [{
      key: 'getName',
      value: function getName() {
        return this.deviceName;
      }

      /**
       * Reads device status.
       * @return {Promise<DeviceStatusResponse,Error>} device status
       */
    }, {
      key: 'readStatus',
      value: function readStatus() {
        return connector.readDeviceStatus(this.deviceName);
      }

      /**
       * Reads device info.
       * @return {Promise<DeviceInfo,Error>} device info
       */
    }, {
      key: 'readInfo',
      value: function readInfo() {
        return connector.readDeviceInfo(this.deviceName);
      }

      /**
       * Reads list of attribute names.
       * @return {Promise<string[],Error>} attribute names
       */
    }, {
      key: 'readAttributesList',
      value: function readAttributesList() {
        return connector.readAttributesList(this.deviceName);
      }

      /**
       * Factory method for {@link DeviceAttribute} instances.
       * @param {string} attributeName attribute name
       * @return {DeviceAttribute} attribute proxy
       */
    }, {
      key: 'createDeviceAttribute',
      value: function createDeviceAttribute(attributeName) {
        return new DeviceAttribute(this, attributeName);
      }

      /**
       * Reads attribute value.
       * @param {string} attributeName attribute name
       * @return {Promise<AttributeReadResponse,Error>} result
       */
    }, {
      key: 'readAttributeValue',
      value: function readAttributeValue(attributeName) {
        return connector.readAttributeValue(this.deviceName, attributeName);
      }

      /**
       * Writes attribute value.
       * Returns promise of stored value (if sync is true)
       * or undefined (if sync is false).
       * @param {string}   attributeName  attribute name
       * @param {Object}   value          value to write
       * @param {boolean}  [sync=false]   synchronous / asynchronous call
       * return {Promise<AttributeReadResponse,Error>|Promise<undefined|Error}
       */
    }, {
      key: 'writeAttributeValue',
      value: function writeAttributeValue(attributeName, value) {
        var sync = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        var nv = [[attributeName, value]];
        var bulk = this.writeAttributeValuesBulk(nv, sync, false);
        return bulk.then(function (r) {
          return (r || [undefined])[0];
        });
      }

      /**
       * Writes values into multiple attributes.
       * Returns promise of stored values (if sync is true)
       * or undefined (if sync is false).
       * @param {Object[][]}  nameValueTuples  list of 2-element lists [name, value]
       * @param {boolean}     [sync=false]     synchronous / asynchronous call
       * @param {boolean}     [reset=false]    reset not specified attributes
       * @return {Promise<AttributeReadResponse[],Error>|Promise<undefined|Error>}
       */
    }, {
      key: 'writeAttributeValuesBulk',
      value: function writeAttributeValuesBulk(nameValueTuples) {
        var sync = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
        var reset = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        return connector.writeAttributeValuesBulk(this.deviceName, nameValueTuples, sync, reset);
      }

      /**
       * Reads attribute info.
       * @param {string} attributeName attribute name
       * @return {Promise<AttributeInfo,Error>} result
       */
    }, {
      key: 'readAttributeInfo',
      value: function readAttributeInfo(attributeName) {
        return connector.readAttributeInfo(this.deviceName, attributeName);
      }

      /**
       * Factory method for {@link DeviceCommand} instances.
       * @param {string} commandName command name
       * @return {DeviceCommand} command proxy
       */
    }, {
      key: 'createDeviceCommand',
      value: function createDeviceCommand(commandName) {
        return new DeviceCommand(this, commandName);
      }

      /**
       * Reads list of command names.
       * @return {Promise<string[],Error>} command names
       */
    }, {
      key: 'readCommandsList',
      value: function readCommandsList() {
        return connector.readCommandsList(this.deviceName);
      }

      /**
       * Reads command info.
       * @param {string} commandName command name
       * @return {Promise<CommandInfo,Error>} result
       */
    }, {
      key: 'readCommandInfo',
      value: function readCommandInfo(commandName) {
        return connector.readCommandInfo(this.deviceName, commandName);
      }

      /**
       * Executes command. Pass undefined as argument for 0-arity commands.
       * Returns execution result (if sync is true) or undefined (if sync is false).
       * @param {string}   commandName      command name
       * @param {Object}   [arg=undefined]  input argument
       * @param {boolean}  [sync=false]     synchronous / asynchronous call
       * @return {Promise<CommandOutputResponse,Error>|Promise<undefined|Error>
       */
    }, {
      key: 'executeCommand',
      value: function executeCommand(commandName) {
        var arg = arguments.length <= 1 || arguments[1] === undefined ? undefined : arguments[1];
        var sync = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        return connector.executeCommand(this.deviceName, commandName, arg, sync);
      }

      // TODO add support for events

      // TODO add support for properties
    }]);

    return DeviceProxy;
  })();

  var TimestampedResponse = (function () {

    /**
     * @param {number} timestamp time when this value was created
     */

    function TimestampedResponse(timestamp) {
      _classCallCheck(this, TimestampedResponse);

      /** @private */
      this._timestamp = timestamp;
    }

    /** Represents result of reading an attribute. */

    /** @type {number} */

    _createClass(TimestampedResponse, [{
      key: 'timestamp',
      get: function get() {
        return this._timestamp;
      }
    }]);

    return TimestampedResponse;
  })();

  var AttributeReadResponse = (function (_TimestampedResponse) {
    _inherits(AttributeReadResponse, _TimestampedResponse);

    /**
     * @param {number} timestamp
     * @param {Object} argout
     * @param {AttributeQuality} quality
     */

    function AttributeReadResponse(timestamp, argout, quality) {
      _classCallCheck(this, AttributeReadResponse);

      _get(Object.getPrototypeOf(AttributeReadResponse.prototype), 'constructor', this).call(this, timestamp);
      /** @private */
      this._argout = argout;
      /** @private */
      this._quality = quality;
      Object.freeze(this);
      Object.freeze(this._argout);
      Object.freeze(this._quality);
    }

    /** Represents result of executing a command. */

    /** @type {Object} */

    _createClass(AttributeReadResponse, [{
      key: 'argout',
      get: function get() {
        return this._argout;
      }

      /** @type {AttributeQuality} */
    }, {
      key: 'quality',
      get: function get() {
        return this._quality;
      }
    }]);

    return AttributeReadResponse;
  })(TimestampedResponse);

  var CommandOutputResponse = (function (_TimestampedResponse2) {
    _inherits(CommandOutputResponse, _TimestampedResponse2);

    /**
     * @param {number} timestamp
     * @param {Object} argout
     */

    function CommandOutputResponse(timestamp, argout) {
      _classCallCheck(this, CommandOutputResponse);

      _get(Object.getPrototypeOf(CommandOutputResponse.prototype), 'constructor', this).call(this, timestamp);
      /** @private */
      this._argout = argout;
      Object.freeze(this);
      Object.freeze(this._argout);
    }

    /** Status and state of a device. */

    /** @type {Object} */

    _createClass(CommandOutputResponse, [{
      key: 'argout',
      get: function get() {
        return this._argout;
      }
    }]);

    return CommandOutputResponse;
  })(TimestampedResponse);

  var DeviceStatusResponse = (function (_TimestampedResponse3) {
    _inherits(DeviceStatusResponse, _TimestampedResponse3);

    /**
     * @param {number} timestamp
     * @param {DeviceState} state
     * @param {string} status
     */

    function DeviceStatusResponse(timestamp, state, status) {
      _classCallCheck(this, DeviceStatusResponse);

      _get(Object.getPrototypeOf(DeviceStatusResponse.prototype), 'constructor', this).call(this, timestamp);
      /** @private */
      this._state = state;
      /** @private */
      this._status = status;
      Object.freeze(this);
      Object.freeze(this._state);
      Object.freeze(this._status);
    }

    /**
     * Enum factory. Enum is a function that maps value to the corresponding key
     * and has all key-value mappings attached.
     * @private
     * @param {Object} mapping from strings to unique identifiers
     * @return {Object} enum
     */

    /** @type {DeviceState} */

    _createClass(DeviceStatusResponse, [{
      key: 'state',
      get: function get() {
        return this._state;
      }

      /** @type {string} **/
    }, {
      key: 'status',
      get: function get() {
        return this._status;
      }
    }]);

    return DeviceStatusResponse;
  })(TimestampedResponse);

  function Enum(mapping) {

    var reverseMapping = Object.keys(mapping).reduce(function (revMap, key) {
      return (revMap[mapping[key]] = key, revMap);
    }, {});

    return Object.freeze(Object.keys(mapping).reduce(function (revMap, key) {
      return (revMap[key] = mapping[key], revMap);
    }, function (v) {
      return reverseMapping[v];
    }));
  }

  /**
   * Attribute data format.
   * @see http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/tango_java_api/classes/fr/esrf/Tango/AttrDataFormat.html
   */
  var AttributeDataFormat = Enum({
    FMT_UNKNOWN: 3,
    IMAGE: 2,
    SCALAR: 0,
    SPECTRUM: 1
  });

  /**
   * Attribute data type.
   * @see http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/tango_java_api/classes/fr/esrf/Tango/AttributeDataType.html
   */
  var AttributeDataType = Enum({
    ATT_BOOL: 0,
    ATT_DOUBLE: 5,
    ATT_ENCODED: 13,
    ATT_FLOAT: 4,
    ATT_LONG: 2,
    ATT_LONG64: 3,
    ATT_SHORT: 1,
    ATT_STATE: 11,
    ATT_STRING: 10,
    ATT_UCHAR: 6,
    ATT_ULONG: 8,
    ATT_ULONG64: 9,
    ATT_USHORT: 7,
    DEVICE_STATE: 12,
    NO_DATA: 14
  });

  /**
   * Attribute quality.
   * @see http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/tango_java_api/classes/fr/esrf/Tango/AttrQuality.html
   */
  var AttributeQuality = Enum({
    ATTR_ALARM: 2,
    ATTR_CHANGING: 3,
    ATTR_INVALID: 1,
    ATTR_VALID: 0,
    ATTR_WARNING: 4
  });

  /**
   * Attribute write type.
   * @see http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/tango_java_api/classes/fr/esrf/Tango/AttrWriteType.html
   */
  var AttributeWriteType = Enum({
    READ: 0,
    READ_WITH_WRITE: 1,
    READ_WRITE: 3,
    WRITE: 2
  });

  /**
   * Device state.
   * @see http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/tango_java_api/classes/fr/esrf/Tango/DevState.html
   */
  var DeviceState = Enum({
    ALARM: 11,
    CLOSE: 2,
    DISABLE: 12,
    EXTRACT: 5,
    FAULT: 8,
    INIT: 9,
    INSERT: 4,
    MOVING: 6,
    OFF: 1,
    ON: 0,
    OPEN: 3,
    RUNNING: 10,
    STANDBY: 7,
    UNKNOWN: 13
  });

  /**
   * Display level.
   * @see http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/tango_java_api/classes/fr/esrf/Tango/DispLevel.html
   */
  var DisplayLevel = Enum({
    EXPERT: 1,
    OPERATOR: 0
  });

  /**
   * Error severity.
   * @see http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/tango_java_api/classes/fr/esrf/Tango/ErrSeverity.html
   */
  var ErrorSeverity = Enum({
    ERR: 1,
    PANIC: 2,
    WARN: 0
  });

  /**
   * Backend-specific connector implementation.
   * @private
   */
  var connector = null;

  /**
   * Sets connector interface implementation.
   * @param {Connector} conn connector implementation
   */
  function setConnector(conn) {
    exports.connector = connector = conn;
  }

  exports.AttributeInfo = AttributeInfo;
  exports.CommandInfo = CommandInfo;
  exports.Connector = Connector;
  exports.Database = Database;
  exports.DeviceAttribute = DeviceAttribute;
  exports.DeviceCommand = DeviceCommand;
  exports.DeviceInfo = DeviceInfo;
  exports.DeviceProxy = DeviceProxy;
  exports.AttributeReadResponse = AttributeReadResponse;
  exports.CommandOutputResponse = CommandOutputResponse;
  exports.DeviceStatusResponse = DeviceStatusResponse;
  exports.AttributeDataFormat = AttributeDataFormat;
  exports.AttributeDataType = AttributeDataType;
  exports.AttributeQuality = AttributeQuality;
  exports.AttributeWriteType = AttributeWriteType;
  exports.DeviceState = DeviceState;
  exports.DisplayLevel = DisplayLevel;
  exports.ErrorSeverity = ErrorSeverity;
  exports.InvalidDeviceNameException = InvalidDeviceNameException;
  exports.connector = connector;
  exports.setConnector = setConnector;
});
//# sourceMappingURL=tangojs.js.map
