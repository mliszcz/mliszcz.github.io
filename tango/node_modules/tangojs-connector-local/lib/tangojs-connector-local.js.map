{"version":3,"sources":["tangojs-connector-local.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UA8VS,cAAc,GAAd,cAAc","file":"tangojs-connector-local.js","sourcesContent":["/** @private */\nlet wrapAsPromisedArray = (x) => Promise.resolve(Array.isArray(x) ? x : [x])\n\n\n/** @private */\nlet extractPropnames = (propnames) => {\n  return (Array.isArray(propnames) ? propnames : [propnames])\n    .map(p => (p instanceof tangojs.struct.DbDatum) ? p.name\n            : (typeof p === 'string' || p instanceof String) ? p\n            : '')\n    .filter(p => p !== '')\n}\n\n\n/** @private */\nlet asRegex = (pattern) => new RegExp(pattern.replace('*', '.*'), 'g')\n\n\n/** @private */\nconst slash = new RegExp('/', 'g')\n\n/** @private */\nfunction flatten(object, depth, separator) {\n  return (depth === 1) ? object\n  : Object.keys(object).reduce((flattened, key1) => {\n    let value = object[key1]\n    let merged\n    if (typeof value !== 'object' || value == null) {\n      merged = {}\n      merged[key1] = value\n    } else {\n      let child = flatten(object[key1], depth-1, separator)\n      merged = Object.keys(child).reduce((acc, key2) => {\n        acc[`${key1}${separator}${key2}`] = child[key2]\n        return acc\n      }, {})\n    }\n    return Object.assign(flattened, merged)\n  }, {})\n}\n\n\n/** @private */\nfunction reject(message) {\n  return Promise.reject(new Error(message))\n}\n\nclass DeviceTreeInspector {\n\n  /**\n   * @param {Object} model\n   */\n  constructor(model) {\n    /** @private */\n    this._model = model\n  }\n\n  /**\n   * @param {string} devname\n   * @return {Promise<Object>}\n   */\n  getDevice(devname) {\n    try {\n      let [domain, family, member] = devname.split('/')\n      return Promise.resolve(this._model[domain][family][member])\n    } catch (error) {\n      return reject(`Invalid device name: '${name}'`)\n    }\n  }\n\n  /**\n   * @param {string} devname\n   * @param {string} attname\n   * @return {Promise<Object>}\n   */\n  getAttribute(devname, attname) {\n    return this.getDevice(devname).then(device =>\n      device.attributes && device.attributes[attname]\n        ? device.attributes[attname]\n        : reject(`Attribute not found: '${devname}/${attname}'`)\n    )\n  }\n\n  /**\n   * @param {string} devname\n   * @param {string} cmdname\n   * @return {Promise<Object>}\n   */\n  getCommand(devname, cmdname) {\n    return this.getDevice(devname).then(device =>\n      device.commands && device.commands[cmdname]\n        ? device.commands[cmdname]\n        : reject(`Command not found: '${devname}/${cmdname}'`)\n    )\n  }\n\n  /**\n   * @param {string} devname\n   * @param {string} propname\n   * @return {Promise<Object>}\n   */\n  getProperty(devname, propname) {\n    return this.getDevice(devname).then(device =>\n      device.properties && device.properties[propname]\n        ? device.properties[propname]\n        : reject(`Property not found: '${devname}/${propname}'`)\n    )\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   */\n  getDeviceNameList() {\n    return Object.keys(flatten(this._model, 3, '/'))\n      .filter(key => (key.match(slash) || []).length === 2)\n  }\n}\n\n\n/**\n * In-memory connector implementation.\n */\nclass LocalConnector extends tangojs.Connector {\n\n  /**\n   * @param {Object} model\n   * @param {DeviceTreeInspector} treeInspector\n   */\n  constructor(model, inspector) {\n    super()\n    /** @private */\n    this._model = model\n    /** @private */\n    this._tree = inspector || new DeviceTreeInspector(model)\n  }\n\n  /**\n   * @return {Promise<string>}\n   * @param {string} devname\n   */\n  get_device_status(devname) {\n    return this._tree.getDevice(devname)\n      .then(device => device.get_status())\n  }\n\n  /**\n   * @return {Promise<DevState>}\n   * @param {string} devname\n   */\n  get_device_state(devname) {\n    return this._tree.getDevice(devname)\n      .then(device => device.get_state())\n  }\n\n  /**\n   * @return {Promise<DeviceInfo>}\n   * @param {string} devname\n   */\n  get_device_info(devname) {\n    return this._tree.getDevice(devname)\n      .then(device => device.get_info())\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} pattern\n   */\n  get_device_list(pattern) {\n    let regex = asRegex(pattern)\n    return this._tree.getDeviceNameList()\n      .then(list => list.filter(s => s.match(regex)))\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} pattern\n   */\n  get_device_domain(pattern) {\n    throw new Error(pattern)\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} pattern\n   */\n  get_device_family(pattern) {\n    throw new Error(pattern)\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} pattern\n   */\n  get_device_member(pattern) {\n    throw new Error(pattern)\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} devname\n   * @param {string} pattern\n   */\n  get_device_property_list(devname, pattern) {\n    let regex = asRegex(pattern)\n    return this._tree.getDevice(devname)\n      .then(device => Object.keys(device.properties)\n                        .filter(s => s.match(regex)))\n  }\n\n  /**\n   * @return {Promise<DbDatum>|Promise<DbDatum[]>}\n   * @param {string} devname\n   * @param {string|string[]|DbDatum[]} propnames\n   */\n  get_device_property(devname, propnames) {\n    let props = extractPropnames(propnames)\n      .map(p => this._tree.getProperty(devname, p))\n    return Array.isArray(propnames) ? Promise.all(props) : props[0]\n  }\n\n  /**\n   * @return {Promise<undefined>}\n   * @param {string} devname\n   * @param {DbDatum[]} properties\n   */\n  put_device_property(devname, prop) {\n    return this._tree.getDevice(devname).then(device => {\n      device.properties = device.properties || {}\n      device.properties[prop.name] = prop\n    })\n  }\n\n  /**\n   * @return {Promise<undefined>}\n   * @param {string} devname\n   * @param {string|string[]|DbDatum[]} propnames property names\n   */\n  delete_device_property(devname, propnames) {\n    return this._tree.getDevice(devname).then(device => {\n      extractPropnames(propnames).forEach(p => {\n        delete device.properties[p]\n      })\n    })\n  }\n\n  /**\n   * @return {Promise<string[]>}\n   * @param {string} devname\n   */\n  get_device_attribute_list(devname) {\n    return this._tree.getDevice(devname)\n      .then(device => Object.keys(device.attributes))\n  }\n\n  /**\n   * @return {Promise<AttributeInfo>|Promise<AttributeInfo[]>}\n   * @param {string} devname\n   * @param {undefined|string|string[]} attnames\n   */\n  get_device_attribute_info(devname, attnames) {\n    let names = attnames ? wrapAsPromisedArray(attnames)\n      : this.get_device_attribute_list(devname)\n    return names.then(names => {\n      return Promise.all(names.map(n => {\n        return this._tree.getAttribute(devname, n)\n          .then(a => a.get_info())\n      }))\n    })\n    .then(infos => {\n      return attnames ? Array.isArray(attnames) ? infos : infos[0]\n        : infos\n    })\n  }\n\n  /**\n   * @return {Promise<DeviceAttribute>|Promise<DeviceAttribute[]>}\n   * @param {string} devname\n   * @param {string|string[]} attname\n   */\n  read_device_attribute(devname, attnames) {\n    return wrapAsPromisedArray(attnames).then(attnames => {\n      return Promise.all(attnames.map(attname => {\n        return this._tree.getAttribute(devname, attname)\n          .then(a => a.get_value())\n      }))\n    })\n    .then(attrs => Array.isArray(attnames) ? attrs : attrs[0] )\n  }\n\n  /**\n  * @return {Promise<undefined>}\n   * @param {string} devname\n   * @param {DeviceAttribute|DeviceAttribute[]} attrs\n   */\n  write_device_attribute(devname, attrs) {\n    return wrapAsPromisedArray(attrs)\n      .then(attrs => attrs.map(a => [a.name, a.value]))\n      .then(nvList => Promise.all(nvList.map(([name, value]) =>\n        this._tree.getAttribute(devname, name)\n          .then(attr => attr.set_value(value))\n      )))\n  }\n\n  /**\n   * @return {Promise<DeviceAttribute>|Promise<DeviceAttribute[]>}\n   * @param {string} devname\n   * @param {DeviceAttribute|DeviceAttribute[]} attrs\n   */\n  write_read_device_attribute(devname, attrs) {\n    attrs\n    throw new Error('not implemented yet')\n  }\n\n  /**\n   * @return {Promise<DeviceData>}\n   * @param {string} devname\n   * @param {string} cmdname\n   * @param {undefined|DeviceData} argin\n   */\n  device_command_inout(devname, cmdname, argin) {\n    return this._tree.getCommand(devname, cmdname)\n      .then(cmd => cmd.inout(argin))\n  }\n\n  /**\n   * @return {Promise<CommandInfo>}\n   * @param {string} devname\n   * @param {string} cmdname\n   */\n  device_command_query(devname, cmdname) {\n    return this._tree.getCommand(devname, cmdname)\n      .then(cmd => cmd.get_info())\n  }\n\n  /**\n   * @return {Promise<CommandInfo[]>}\n   * @param {string} devname\n   */\n  device_command_list_query(devname) {\n    return this._tree.getDevice(devname)\n      .then(device => Object.keys(device.commands))\n      .then(cmdnames => Promise.all(\n        cmdnames.map(cmdname =>\n          this._tree.getCommand(devname, cmdname)\n            .then(cmd => cmd.get_info())\n        )\n      ))\n  }\n}\n\nexport { LocalConnector };"],"sourceRoot":"/source/"}