(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['exports', 'tangojs'], factory);
  } else if (typeof exports !== 'undefined') {
    factory(exports, require('tangojs'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.tangojs);
    global.tangojsConnectorLocal = mod.exports;
  }
})(this, function (exports, _tangojs) {
  // FIXME '* as' should not be there
  // https://github.com/babel/babel/issues/95

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });

  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  /** @private */
  function now() {
    return new Date().getTime();
  }

  /** @private */
  function reject(message) {
    return Promise.reject(new Error(message));
  }

  /**
   * In-memory connector implementation.
   */

  var LocalConnector = (function (_tangojs$Connector) {
    _inherits(LocalConnector, _tangojs$Connector);

    /**
     * @param {Object} data model
     */

    function LocalConnector(model) {
      _classCallCheck(this, LocalConnector);

      _get(Object.getPrototypeOf(LocalConnector.prototype), 'constructor', this).call(this);
      /** @private */
      this._model = model;
    }

    /** @private */

    _createClass(LocalConnector, [{
      key: '_devicePromise',
      value: function _devicePromise(name) {
        try {
          var _name$split = name.split('/');

          var _name$split2 = _slicedToArray(_name$split, 3);

          var domain = _name$split2[0];
          var family = _name$split2[1];
          var member = _name$split2[2];

          return Promise.resolve(this._model[domain][family][member]);
        } catch (error) {
          return reject('Invalid device name: \'' + name + '\'');
        }
      }

      /** @private */
    }, {
      key: '_attributePromise',
      value: function _attributePromise(deviceName, attributeName) {
        return this._devicePromise(deviceName).then(function (device) {
          return device.attributes && device.attributes[attributeName] ? device.attributes[attributeName] : reject('Attribute not found: \'' + deviceName + '/' + attributeName + '\'');
        });
      }

      /** @private */
    }, {
      key: '_commandPromise',
      value: function _commandPromise(deviceName, commandName) {
        return this._devicePromise(deviceName).then(function (device) {
          return device.commands && device.commands[commandName] ? device.commands[commandName] : reject('Command not found: \'' + deviceName + '/' + commandName + '\'');
        });
      }

      // --- tangojs.Connector implementation starts here ---

    }, {
      key: 'dbReadDomains',
      value: function dbReadDomains() {
        return this._model ? Promise.resolve(Object.keys(this._model)) : Promise.reject(new Error('Invalid model'));
      }
    }, {
      key: 'dbReadFamilies',
      value: function dbReadFamilies(domain) {
        return this._model && this._model[domain] ? Promise.resolve(Object.keys(this._model[domain])) : Promise.reject(new Error('Invalid domain: \'' + domain + '\''));
      }
    }, {
      key: 'dbReadMembers',
      value: function dbReadMembers(domain, family) {
        return this._model && this._model[domain] && this._model[domain][family] ? Promise.resolve(Object.keys(this._model[domain][family])) : Promise.reject(new Error('Invalid domain: \'' + domain + '\' or family: \'' + family + '\''));
      }
    }, {
      key: 'readDeviceStatus',
      value: function readDeviceStatus(deviceName) {
        return this._devicePromise(deviceName).then(function (device) {
          var _device$status = device.status();

          var _device$status2 = _slicedToArray(_device$status, 2);

          var state = _device$status2[0];
          var status = _device$status2[1];

          return new _tangojs.DeviceStatusResponse(now(), state, status);
        });
      }
    }, {
      key: 'readDeviceInfo',
      value: function readDeviceInfo(deviceName) {
        return this._devicePromise(deviceName).then(function (device) {
          return new _tangojs.DeviceInfo(device.info());
        });
      }
    }, {
      key: 'readAttributesList',
      value: function readAttributesList(deviceName) {
        return this._devicePromise(deviceName).then(function (device) {
          return Object.keys(device.attributes);
        });
      }
    }, {
      key: 'readAttributeValue',
      value: function readAttributeValue(deviceName, attributeName) {
        return this._attributePromise(deviceName, attributeName).then(function (attribute) {
          return new _tangojs.AttributeReadResponse(now(), attribute.read(), _tangojs.AttributeQuality.ATTR_VALID);
        });
      }
    }, {
      key: 'writeAttributeValuesBulk',
      value: function writeAttributeValuesBulk(deviceName, nameValuePairs) {
        var _this = this;

        var sync = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
        var reset = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

        // attribute objects paired with values to write
        var attributeValuePairsPromises = nameValuePairs.map(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2);

          var name = _ref2[0];
          var value = _ref2[1];
          return _this._attributePromise(deviceName, name).then(function (attr) {
            return [attr, value];
          });
        });

        var quality = _tangojs.AttributeQuality.ATTR_VALID;

        // write values and read stored results (if required)
        var writeAttributeValuePairs = function writeAttributeValuePairs(attributeValuePairs) {
          return attributeValuePairs.map(function (_ref3) {
            var _ref32 = _slicedToArray(_ref3, 2);

            var attr = _ref32[0];
            var value = _ref32[1];
            return [attr, attr.write(value)];
          }).map(function (_ref4) {
            var _ref42 = _slicedToArray(_ref4, 1);

            var attr = _ref42[0];
            return sync ? new _tangojs.AttributeReadResponse(now(), attr.read(), quality) : undefined;
          });
        };

        var changedNames = nameValuePairs.map(function (_ref5) {
          var _ref52 = _slicedToArray(_ref5, 1);

          var n = _ref52[0];
          return n;
        });

        // reset parameters if required
        var resetUnspecifiedIfRequired = !reset ? function (x) {
          return x;
        } : function (readResponses) {
          return _this.readAttributesList(deviceName).then(function (allNames) {
            var nonChangedAttributePromises = allNames.filter(function (name) {
              return !(name in changedNames);
            }).map(function (name) {
              return _this._attributePromise(deviceName, name);
            });
            return Promise.all(nonChangedAttributePromises).then(function (attrs) {
              return attrs.forEach(function (a) {
                return a.reset();
              });
            }).then(function () {
              return readResponses;
            });
          });
        };

        return Promise.all(attributeValuePairsPromises).then(writeAttributeValuePairs).then(resetUnspecifiedIfRequired);
      }
    }, {
      key: 'readAttributeInfo',
      value: function readAttributeInfo(deviceName, attributeName) {
        return this._attributePromise(deviceName, attributeName).then(function (attribute) {
          return new _tangojs.AttributeInfo(attribute.info());
        });
      }
    }, {
      key: 'readCommandsList',
      value: function readCommandsList(deviceName) {
        return this._devicePromise(deviceName).then(function (device) {
          return Object.keys(device.commands);
        });
      }
    }, {
      key: 'readCommandInfo',
      value: function readCommandInfo(deviceName, commandName) {
        return this._commandPromise(deviceName, commandName).then(function (command) {
          return new _tangojs.CommandInfo(command.info());
        });
      }
    }, {
      key: 'executeCommand',
      value: function executeCommand(deviceName, commandName, arg, sync) {
        return this._commandPromise(deviceName, commandName).then(function (command) {
          var result = command.execute(arg);
          return sync ? new _tangojs.CommandOutputResponse(now(), result) : undefined;
        });
      }
    }]);

    return LocalConnector;
  })(_tangojs.Connector);

  exports.LocalConnector = LocalConnector;
});
//# sourceMappingURL=tangojs-connector-local.js.map